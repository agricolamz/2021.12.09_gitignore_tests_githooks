---
title: "`.gitignore`, тесты, git hooks"
author: "Г. Мороз, Н. Хауэлл"
date: "9 декабря 2021"
output: 
  html_document:
    toc: true
    toc_position: right
    toc_depth: 2
    toc_float: yes
    number_sections: true
    df_print: paged
---

```{r setup, include=FALSE}
library('knitr')
knit_hooks$set(prompt = function(before, options, envir) {options(prompt = "$ ")})
opts_chunk$set(comment = "", prompt = TRUE)
```

# Прошлые встречи

* 2021.11.08, [видео](https://youtu.be/oslfxrYjt_A)
* 2021.12.02, [видео](https://youtu.be/3ULre3nuIhU), [материалы](https://agricolamz.github.io/2021.12.02_intro_to_linux_lexd_github_makefiles/)

# Cимволы подстановки (wildcards) в `bash`

В `bash` как и во многих языках программирования есть символы подстановки. Хоть я приведу все примеры с функцией `ls`, но легко представить себе и более осмысленные задачи. У нас есть папка где есть много файлов:

```{bash}
ls multiple_files
```

Мы можем вывести все файлы содержащие двойку, добавив `*` -- любое количество символов:

```{bash}
ls multiple_files/*2*
```

Это же используют для поиска файлов с каким-либо определенным расширением:

```{bash}
ls multiple_files/*.csv
```

Кроме того звездочку можно использовать и без каких либо окружающих символов, тогда будут перечислены все файлы. Например, следующий команда удаляет все файлы в папке `multiple_files`.

```{bash, eval = FALSE}
rm multiple_files/*
```

Если известно точное количество символов, то можно использовать символ `?`, который обозначает один символ. Выведем только файлы с четырьмя символами в названии:

```{bash}
ls multiple_files/????.*
```

Как и раньше, искать можно по расшерению:

```{bash}
ls multiple_files/a_1.???
```

Кроме того можно задавать группы при помощи квадратных скобок:

```{bash}
ls multiple_files/[aouie]*
```

# `.gitignore`
Символы подстановки очень полезны при создании файла `.gitignore`. `.gitignore` --- это специальный скрытый файл[^hidden], в котором вы можете перечислить файлы, которые `git` должен игнорировать (см. [документацию](https://git-scm.com/docs/gitignore)). 

[^hidden]: Скрытые файлы или дериктории начинаются с точки и не высвечиваются по команде `ls` (но высвечиваются по команде `ls -a`). Скрытые файлы часто хронят конфигурационные файлы или какие данные, которые используют программы. Эта категория файлов создано, чтобы пользователь случайно не переписал или удалил какой-то из файлов. 

В [прошлый раз](https://agricolamz.github.io/2021.12.02_intro_to_linux_lexd_github_makefiles/) мы обсуждали, что при создании морфологического анализатора в формате `lexd` нам достаточно обмениваться файлами `.lexd` и соответствующим `Makefile`ом, а результирующие файлы вроде `.hfst` и `.hfstol` (мы об этих еще не говорили) хотелось бы случайно не закоммитить на GitHub. В связи с этим в вашем репозитории имеет смысл перечислить файлы, которые мы хотим, чтобы не были на GutHub:

```.gitignore
*.att
*.hfst
*.hfstol
```

Позже может так случится, что вы будете хранить в той же папке литературу и/или данные, которые нельзя выкладывать, их тоже можно будет добавить в `.gitignore`. Кроме того у GitHub есть ограничения на размер файла (вроде 100мб?..), если он увидит большие файлы, то он не даст их закоммитить, так что если они есть в вашем проекте, их тоже можно будет добавить в `.gitignore`.

# Тесты

Существует такое понятие как разработка через тестирование (Test-driven development). Концепция заключается в том, что когда у нас есть какая-то идея, мы можем сначала написать тесты, которые описывают, как работает наша программа, а потом уже писать программу. Когда программа написана или переписана, происходит проверка тестов. В результате, мы можем проверить соответствие наших ожиданий и реальности. В нашем случае таким тестом является правильный разбор трансдьюссером форм. Для этого Ник в прошлом году написал программу, работы которой нужны следующие компоненты:

* работающий файл `.lexd` (мы возьмем файл с прошлого занятия)
* работающий `Makefile` (мы напишем сейчас новый)
* соответствия анализ-форма-источник; в нашем случае это будет файл `tests.csv` (можно скачать вот [здесь](https://raw.githubusercontent.com/agricolamz/2021.12.09_gitignore_tests_githooks/master/tests.csv))

```{r, echo=FALSE}
read.csv("tests.csv")
```

* `bash` скрипт, который Ник написал в прошлом году (можно скачать [здесь](https://raw.githubusercontent.com/agricolamz/2021.12.09_gitignore_tests_githooks/master/compare.sh))

После того, как мы поместили все файлы вместе, нам нужно исправить `Makefile`:

```
.DEFAULT_GOAL := clean

and.noun.analizer.hfst: and.noun.generator.hfst
	hfst-invert $< -o $@
and.noun.generator.hfst: and.noun.lexd
	lexd $< | hfst-txt2fst -o $@
test.pass.txt: tests.csv
	awk -F, '$$3 == "pass" {print $$1 ":" $$2}' $^ | sort -u > $@
check: and.noun.generator.hfst test.pass.txt
	bash compare.sh $< test.pass.txt
clean: check
	rm test.*
```

Теперь, если изменить файл `.lexd` (а именно как-то изменить форму супер-элатива), то на команду `make` будет выдаваться ошибка.

# `git hooks`

Кажется удобным, чтобы проверки, которые мы сейчас обсудили, можно было проводить каждый раз перед тем как комитить изменения на GitHub. Для этого были предуманы `git hooks` (для углубления почитайте [документацию](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)). В нашем случае нужно сделать файл `.git/hooks/pre-commit` со следующим содержанием:

```
#!/bin/sh

make check
```
